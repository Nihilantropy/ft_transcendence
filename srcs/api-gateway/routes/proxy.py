from fastapi import APIRouter, Request, HTTPException
from starlette.responses import Response
from starlette.datastructures import MutableHeaders
import httpx
import json
from config import settings
from datetime import datetime
from typing import Dict, Any, List, Tuple

router = APIRouter()

# Async HTTP client for backend requests
httpx_client = httpx.AsyncClient(timeout=30.0)


class ProxyResponse(Response):
    """
    Custom Response class that accepts raw_headers in constructor.
    This is needed to properly forward multiple Set-Cookie headers from backend.
    """
    def __init__(
        self,
        content: bytes,
        status_code: int,
        raw_headers: List[Tuple[bytes, bytes]],
        **kwargs
    ):
        super().__init__(content=content, status_code=status_code, **kwargs)
        # Replace the raw_headers list generated by parent __init__
        self.raw_headers = raw_headers

# Service routing map
# NOTE: RAG endpoints are internal-only (used by vision pipeline, not exposed to users)
# NOTE: Longer prefixes must come before shorter ones for correct matching
SERVICE_ROUTES = {
    "/api/v1/auth": settings.AUTH_SERVICE_URL,
    "/api/v1/users": settings.USER_SERVICE_URL,
    "/api/v1/pets": settings.USER_SERVICE_URL,
    "/api/v1/vision": settings.AI_SERVICE_URL,
    # "/api/v1/rag": Intentionally not exposed - internal use only
    "/api/v1/recommendations": settings.RECOMMENDATION_SERVICE_URL,
    "/api/v1/admin/products": settings.RECOMMENDATION_SERVICE_URL,  # Product management admin
}

def get_backend_service_url(path: str) -> str:
    """
    Determine which backend service to route to based on path.

    Args:
        path: Request path (e.g., /api/v1/auth/login)

    Returns:
        Backend service base URL

    Raises:
        HTTPException: If no matching service found
    """
    for prefix, service_url in SERVICE_ROUTES.items():
        if path.startswith(prefix):
            return service_url

    raise HTTPException(
        status_code=404,
        detail={"error": {"code": "NOT_FOUND", "message": "Service not found"}}
    )

async def forward_request(
    request: Request,
    backend_url: str,
    path: str,
    method: str
) -> Dict[str, Any]:
    """
    Forward request to backend service with user context headers.

    Args:
        request: FastAPI request object
        backend_url: Backend service base URL
        path: Request path
        method: HTTP method

    Returns:
        Backend service response as dict
    """
    # Get user context headers from middleware
    backend_headers = getattr(request.state, "backend_headers", {})

    # Forward original headers (except host)
    forward_headers = dict(request.headers)
    forward_headers.pop("host", None)

    # Strip cookies for non-auth endpoints (auth service needs cookies for refresh/logout)
    if not path.startswith("/api/v1/auth"):
        forward_headers.pop("cookie", None)

    # Merge with user context headers
    forward_headers.update(backend_headers)

    # Build full backend URL
    full_url = f"{backend_url}{path}"

    # Get request body if present
    body = None
    if method in ["POST", "PUT", "PATCH"]:
        body = await request.body()

    try:
        # Forward request to backend
        response = await httpx_client.request(
            method=method,
            url=full_url,
            headers=forward_headers,
            content=body,
            params=dict(request.query_params)
        )

        # Try to parse JSON, fallback to raw content
        content = None
        if response.content:
            try:
                content = response.json()
            except Exception:
                # Non-JSON response (e.g., HTML error pages)
                content = None

        return {
            "status_code": response.status_code,
            "content": content,
            "headers": dict(response.headers),
            "raw_response": response  # Keep raw response for Set-Cookie handling
        }

    except httpx.RequestError as e:
        raise HTTPException(
            status_code=503,
            detail={
                "success": False,
                "error": {
                    "code": "SERVICE_UNAVAILABLE",
                    "message": f"Backend service unavailable: {str(e)}",
                    "details": {}
                },
                "timestamp": datetime.utcnow().isoformat()
            }
        )

@router.api_route("/api/{path:path}", methods=["GET", "POST", "PUT", "DELETE", "PATCH"])
async def proxy_handler(request: Request, path: str):
    """
    Universal proxy handler that routes requests to appropriate backend services.
    """
    # Construct full path
    full_path = f"/api/{path}"

    # Determine backend service
    backend_url = get_backend_service_url(full_path)

    # Forward request
    backend_response = await forward_request(
        request=request,
        backend_url=backend_url,
        path=full_path,
        method=request.method
    )

    # Build response from backend, preserving all headers including multiple Set-Cookie
    raw_response = backend_response.get("raw_response")

    if raw_response:
        # Centralized error response normalization
        # Convert HTML error pages (404, 500, etc.) to standardized JSON format
        content_type = raw_response.headers.get('content-type', '')
        status_code = raw_response.status_code
        
        # Handle 404 Not Found errors
        if status_code == 404 and 'text/html' in content_type:
            error_response = {
                "success": False,
                "data": None,
                "error": {
                    "code": "NOT_FOUND",
                    "message": "The requested resource was not found",
                    "details": {}
                },
                "timestamp": datetime.utcnow().isoformat()
            }
            return Response(
                content=json.dumps(error_response),
                status_code=404,
                media_type="application/json"
            )
        
        # Handle 500 Internal Server Error (often caused by invalid route params)
        if status_code == 500 and 'text/html' in content_type:
            # Check if it's a Django "Not Found" error disguised as 500
            # (happens when URL patterns don't match - e.g., invalid UUID)
            if b'Not Found' in raw_response.content or b'DoesNotExist' in raw_response.content:
                error_response = {
                    "success": False,
                    "data": None,
                    "error": {
                        "code": "NOT_FOUND",
                        "message": "The requested resource was not found",
                        "details": {}
                    },
                    "timestamp": datetime.utcnow().isoformat()
                }
                return Response(
                    content=json.dumps(error_response),
                    status_code=404,
                    media_type="application/json"
                )
            else:
                # Generic 500 error
                error_response = {
                    "success": False,
                    "data": None,
                    "error": {
                        "code": "INTERNAL_ERROR",
                        "message": "An internal server error occurred",
                        "details": {}
                    },
                    "timestamp": datetime.utcnow().isoformat()
                }
                return Response(
                    content=json.dumps(error_response),
                    status_code=500,
                    media_type="application/json"
                )
        
        # Use ProxyResponse with raw_headers to preserve all headers including duplicates
        return ProxyResponse(
            content=raw_response.content,
            status_code=raw_response.status_code,
            raw_headers=list(raw_response.headers.raw)  # Preserve all headers as-is
        )
    else:
        # Fallback if no raw response
        return Response(
            content=backend_response["content"],
            status_code=backend_response["status_code"]
        )
